<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#
	var filename = this.Host.ResolvePath("RqliteGetScalarResponseExtensionsInput.csv");
	var lines = File.ReadLines(filename);
#>
// Maybe: Rqlite Client for .NET.
// Copyright (c) bfren - licensed under https://mit.bfren.dev/2023

using System;
using System.Text.Json;
using System.Threading.Tasks;

namespace Rqlite.Client;

public static partial class RqliteGetScalarResponseExtensions
{
<# foreach (string line in lines) { var type = line.Split(','); #>
	/// <summary>
	/// Flatten <paramref name="response"/> and return the first <see cref="<#= type[1] #>"/> or <see cref="<#= type[2] #>"/>.
	/// </summary>
	/// <remarks>Warning: any errors will be ignored and an empty list returned instead!</remarks>
	/// <param name="response">RqliteGetScalarResponse object.</param>
	/// <returns>First <see cref="<#= type[1] #>"/> or <see cref="<#= type[2] #>"/>.</returns>
	public static <#= type[1] #> Flatten(this RqliteGetScalarResponse<<#= type[1] #>> response) =>
		Flatten(response, (JsonElement e, out <#= type[1] #> v) => e.TryGet<#= type[0] #>(out v), <#= type[2] #>);

	/// <inheritdoc cref="Flatten(RqliteGetScalarResponse{<#= type[1] #>})"/>
	public static async Task<<#= type[1] #>> Flatten(this Task<RqliteGetScalarResponse<<#= type[1] #>>> response) =>
		Flatten(await response);

<# } #>
}